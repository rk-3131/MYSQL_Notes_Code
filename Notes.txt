1. the new database for our sql client

CREATE DATABASE database_name;

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
+--------------------+
5 rows in set (0.03 sec)

mysql> CREATE DATABASE temp1
    -> ;
Query OK, 1 row affected (0.29 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| temp1              |
+--------------------+
6 rows in set (0.10 sec)

mysql> CREATE DATABASE temp2;
Query OK, 1 row affected (0.01 sec)

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| temp1              |
| temp2              |
+--------------------+
7 rows in set (0.00 sec)

while creating the database we can make additional parameter in the database and hence that will help us to avoid error
we can use IF NOT EXIST
CREATE DATABASE IF NOT EXIST college;
This is the query which will not give any error if the database is already present in the database but warning will be given to us not error.
But if the database is not present then it will be created no matter what.


2. Deleting the database from the client

DROP DATABASE database_name;

mysql> DROP DATABASE temp2
    -> ;
Query OK, 0 rows affected (0.09 sec)

mysql> SHOW DATABASE;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DATABASE' at line 1
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| temp1              |
+--------------------+
6 rows in set (0.01 sec)

mysql> DROP DATABASE temp1;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

while deleting the database from the schema we have to make sure that the database exist in the client
There we will be using the IF EXIST in the database

DROP DATABASE IF EXIST database_name;


3. For selecting the database to work on in the list of databases we have to use the command 'use'
This use will select the database to work in the environment

USE database_name;

mysql> CREATE DATABASE college;
Query OK, 1 row affected (0.01 sec)

mysql> use DATABASE;
ERROR 1049 (42000): Unknown database 'database'
mysql> use college;
Database changed


4. For creating the table in the database we have to first select the database out of the list of database where we have to create the table
After selecting the database we will create the table in the database using the syntax given below

CREATE TABLE table_name(
	column_1 datatype constraint, 
	column_2 datatype constraint, 
	column_3 datatype constraint
)

mysql> use college;
Database changed

mysql> CREATE TABLE student (
    -> id INT PRIMARY KEY, name VARCHAR(50), age INT NOT NULL);
Query OK, 0 rows affected (0.22 sec)

For inserting the data into the table we have to make sure that the data and the values in the braces should match with each other

INSERT INTO table_name(column_1, column_2, column_3) VALUES (val1, val2, val3), (val1, val2, val3);

mysql> INSERT INTO student(id, name, age) VALUES (1, "Radhakrushna Mahadik", 22);
Query OK, 1 row affected (0.07 sec)

mysql> INSERT INTO student (id, name, age) VALUES (2, "Piyush More", 22), (3, "Saurabh Nikam", 23);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0



For getting the records in the database we can use the SELECT command
SELECT command will give us the list of all the elements which are present in the mentioned table 
Syntax :
	SELECT * FROM table_name;

mysql> SELECT * FROM student;
+----+----------------------+-----+
| id | name                 | age |
+----+----------------------+-----+
|  1 | Radhakrushna Mahadik |  22 |
|  2 | Piyush More          |  22 |
|  3 | Saurabh Nikam        |  23 |
+----+----------------------+-----+
3 rows in set (0.02 sec)


Datatypes in the MySQL

1. CHAR : It can store string of 0 - 255 
	But the CHAR is fixed size its size once fixed it cant be changed
	i.even if we store the values in the database in less than that of what we have declared in the database the memory that might remain will be wasted and we or the server will not be able to utilize that free memory

2. VARCHAR : It is also used to store the string of length 0- 255
	Advantage of VARCHAR is that the sql server can utilize the free memory left behind after assigning the values to the string
	i.e even if we declare the values of the database as 255 and we assign the string of length 10 then the remaining values can be accessed by us which is not possible when using the CHAR datatype

BLOB(size):
	BLOB can be used to store the large binary objects of length larger than that of 1000
	range :- (0-65535)

INT : It is used to store the integer value in the range of 32 bits

TINYINT : It is used to store in the range (-128 to 127)


BIT() : It is used to store the x ammount of bit values
for eg: BIT(2) here only 2 bit value can be stored
	We can change the values as per our requirement


FLOAT : It is used to store the decimal values of precision upto 23 digits

DOUBLE : It is used to store the FLOAT digits of much higher values


BOOLEAN : it is used to store the boolean true or false values

DATE : This is used to get the date in the format of YYYY-MM-DD 
We can even give it range so that the date will be in particular range only

These numeric datatypes can be signed or unsigned
When we want increase the range of the numeric datatypes we can make them unsigned
like range of TINYINT is (-128 to 127) then we can make it unsigned and hence range of the TINYINT will be now increased to (0-255)



Types of SQL Command: 

1. DDL : Data definition language (Schema of the table)
2. DML : CRUD operations
3. DCL : GRANT and REVOKE permissions
4. TCL : start transaction, commit, rollback


We can get the list of all the tables which are present in the given database by using the show table command

SHOW TABLES;
The out put will be list of all the tables which are present in the table

If we want to delete the table in the database then it can be done by using the drop command

Syntax : DROP TABLE table_name;

mysql> DROP TABLE student;
Query OK, 0 rows affected (0.40 sec)


When we want to see all the data that is stored in particular table then it can be retrieved by using the Command Select
SELECT will give us records in the table based on certain condition

Syntax : SELECT * FROM table name;
here * means every column in the database and not selected columns
We can get selected columns from the database by specifying particular names of the databases


Insert into is used to insert records in the table using commands

Syntax : INSERT INTO table_name (column1. column2, .... columnn) VALUES (v1, v2, ... vn), (v1, v2, ....., vn);

mysql> INSERT INTO student(rollno, name) VALUES (1, "Radhakrushna"), (2, "Saurabh"), (3, "Piyush");
Query OK, 3 rows affected (0.04 sec)
Records: 3  Duplicates: 0  Warnings: 0

We can add the single or even multiple data if we put the data in specific order then we dont have to specify the names of the columns in advance as it will be clear for the insertion

Syntax : INSERT INTO table_name VALUES (v1, v2, ..., vn), (v1, v2, ...., vn);

mysql> INSERT INTO student VALUES (4, "Avi"), (5, "Nachiket"), (6, "Sushant");
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

This method will be prefered for inserting the single row in the table though it can insert multiple records
This should be preffered for small tables only for larger table first method is well and good

Q: 
	1.Create a database for your company named XYZ
	2.Create table to store emp_info (id, name, salary)
	3.add following information in the db:
		1, adam, 25000
		2, bob, 30000
		3, casey, 40000
	4.Select and view your table

mysql> CREATE DATABASE IF NOT EXISTS XYZ;
Query OK, 1 row affected (0.03 sec)
mysql> USE XYZ IF EXISTS;
Database changed
mysql> CREATE TABLE employee_info(id INT PRIMARY KEY, name VARCHAR(55), salary INT NOT NULL);
Query OK, 0 rows affected (0.11 sec)
mysql> INSERT INTO employee_info(id, name, salary) VALUES (1, "adam", 25000), (2, "bob", 30000), (3, "casey", 40000);
Query OK, 3 rows affected (0.03 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM employee_info;
+----+-------+--------+
| id | name  | salary |
+----+-------+--------+
|  1 | adam  |  25000 |
|  2 | bob   |  30000 |
|  3 | casey |  40000 |
+----+-------+--------+
3 rows in set (0.01 sec)

Keys: 
	1. Primary Key:
		It is column (or group of column) in the table which uniquely identifies each row 
		It will be unique and not null

	2. Foreign Key: 
		Foreign key is primary key in another table which is used to make a reference in the current table
		This is used to have relation between two tables
		There can be multiple foreign key
		They can have duplicate and null values

Contraints :
	They are used to make some specific entry to enter in the database by adding the constraints
	If we want only certain kind of values to be present in the table then it is possible that contraints will be applied in the database

Syntax : 
	column_name datatype constraints
	NOT NULL : This column will not have any null values
	UNIQUE : This column will have unique values
	PRIMARY KEY : Make all column values not null and unique
	FOREIGN KEY : This is the key from another table 
	This key is used as primary key in other table and it will be referenced from that table so that there will be relation between the tables present in all of the tables mentioned

We know one syntax to define a key as primary key
There is another way of making one key as primary key

CREATE TABLE student_info(
	id INT, 
	name VARCHAR(55), 
	age INT NOT NULL,
	PRIMARY KEY(id)
);

We can even make a combination of keys as primary and foreign based on the presence of keys in the datasets

CREATE TABLE student_info(
	id INT, 
	name VARCHAR(55), 
	age INT NOT NULL,
	PRIMARY KEY(id, name)
);
In the above example we have combination of id and name as the primary key of the dataset

CREATE TABLE temp(
	cust_id INT, 
	FOREIGN KEY (cust_id) REFEREBCES customer(id)
);

mysql> CREATE TABLE temp1(id INT, name VARCHAR(50));
Query OK, 0 rows affected (0.22 sec)

mysql> CREATE TABLE temp2(cust_id INT, FOREIGN KEY(cust_id) REFERENCES temp1(id));
ERROR 1822 (HY000): Failed to add the foreign key constraint. Missing index for constraint 'temp2_ibfk_1' in the referenced table 'temp1'
Here I am getting error as the key id in temp1 is not declared as primary key

DEFAULT : 
	it is used to set the default value to the dataset
	Here the value of the default mentioned will be defined while creating the database
	Hence if we specify the salary constraint then it will be added into the database if we dont specify the inputs while inserting the records


mysql> CREATE TABLE temp3 (id INT PRIMARY KEY, salary INT DEFAULT 30000);
Query OK, 0 rows affected (0.06 sec)
Here we have created the table where we have made arrangements such that if we dont specify the salary then by default it will be 25000

mysql> INSERT INTO temp3(id, Salary) VALUES(1, 5000);
Query OK, 1 row affected (0.24 sec)
Now we have added the salary as 5000 and it is explicitely mentioned hence it will be added to the database

mysql> INSERT INTO temp3(id) VALUES(2);
Query OK, 1 row affected (0.01 sec)
In the above query we have not speified in the database about the values about the salary
This is the time where the default value of the salary is added to the database

mysql> SELECT * FROM temp3;
+----+--------+
| id | salary |
+----+--------+
|  1 |   5000 |
|  2 |  30000 |
+----+--------+
2 rows in set (0.00 sec)

mysql> CREATE TABLE temp2 (my_id INT, FOREIGN KEY (id) REFERENCES employee_info(id));
ERROR 1072 (42000): Key column 'id' doesn't exist in table
mysql> CREATE TABLE temp2 (my_id INT, FOREIGN KEY (my_id) REFERENCES employee_info(id));
Query OK, 0 rows affected (0.17 sec)


CHECK:
	It is used to define the limits for the values that need to be added to the database
	Hence CHECK will be used for specifying the range where the values in certain columns can rely on

mysql> CREATE TABLE city(id INT PRIMARY KEY, city VARCHAR(55), age INT, CONSTRAINT age_check CHECK
    -> (age >= 18 AND city ="Pune"));
Query OK, 0 rows affected (0.09 sec)
Here we have created the table where we have specified the constraint about what are limits on the columns age and city

mysql> INSERT INTO city(id, city, age) VALUES (1, "Pune", 20);
Query OK, 1 row affected (0.01 sec)
This record has been added as constraint is not violated

mysql> INSERT INTO city(id, city, age) VALUES (1, "Pune", 12);
ERROR 3819 (HY000): Check constraint 'age_check' is violated.
mysql> INSERT INTO city(id, city, age) VALUES (1, "Mumbai", 22);
ERROR 3819 (HY000): Check constraint 'age_check' is violated.
Here we have got an error as constraint is violated in both of the above cases


We can add the check constraint to the table while declaring the table in other way too

mysql> CREATE TABLE temp2 (id INT PRIMARY KEY, age INT CHECK (age >= 18));
Query OK, 0 rows affected (0.04 sec)
Here we have specified the constraint in the table at the declaration of the variable also

mysql> INSERT INTO temp2(id, age) VALUES(1, 25);
Query OK, 1 row affected (0.02 sec)

mysql> INSERT INTO temp2(id, age) VALUES(2, 15);
ERROR 3819 (HY000): Check constraint 'temp2_chk_1' is violated.


SELECT :
	Select is used to get the results from the table 
	We can specify the name of the columns in the select command 
	If we dont specify names of the columns then * can be used to retrieve all the records from the table
	
Syntax :
	SELECT c1, c2, cn FROM table_name;

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)


mysql> SELECT name from student;
+---------+
| name    |
+---------+
| anil    |
| bhumika |
| chetan  |
| dhruv   |
| emanuel |
| farah   |
+---------+
6 rows in set (0.00 sec)



If we want to have only unique values from the table then we can use DISTINCT keyword in the SELECT command

SELECT DISTINCT name from students;
This will give us the unique names from the students table 

mysql> SELECT DISTINCT city from student;
+--------+
| city   |
+--------+
| Pune   |
| Mumbai |
| Delhi  |
+--------+
3 rows in set (0.01 sec)

WHERE clause:
	This is used to add the condition to the select clause
	It can be used to retrieve the data as per our requirement and hence we can get the results from the data based on the condition that we want to specify

mysql> SELECT * FROM student WHERE marks > 80;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
4 rows in set (0.01 sec)
This is record of all the students whose marks are greater than that of 80

mysql> SELECT grade FROM student WHERE rollno = 104;
+-------+
| grade |
+-------+
| A     |
+-------+
1 row in set (0.00 sec)
Here only grade of the student is retrieved whose rollno is 104

mysql> SELECT name FROM student WHERE marks < 90 AND city = "Mumbai";
+--------+
| name   |
+--------+
| chetan |
+--------+
1 row in set (0.00 sec)
Here we have combined the two condition by using the logical operator


Operators : 
	Atithmetic : +, -, * , /, %
	Comparison : =, !=, >, <, >=, <=
	Logical : AND, OR, NOT, IN, BETWEEN, ALL, LIKE, ANY
	Bitwise : &, |

mysql> SELECT * FROM student where marks + 10 >= 100;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    102 | bhumika |    93 | A     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
+--------+---------+-------+-------+--------+
2 rows in set (0.01 sec)


mysql> SELECT * FROM student where marks + 10 >= 100 OR marks + 10 < 100;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)


mysql> SELECT * FROM student where marks BETWEEN 80 AND 100;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
4 rows in set (0.00 sec)


mysql> SELECT * FROM student WHERE name like 'a%';
+--------+------+-------+-------+------+
| rollno | name | marks | grade | city |
+--------+------+-------+-------+------+
|    101 | anil |    78 | C     | Pune |
+--------+------+-------+-------+------+
1 row in set (0.01 sec)

mysql> SELECT * FROM student WHERE marks IN (100, 25, 85, 98, 92);
+--------+--------+-------+-------+--------+
| rollno | name   | marks | grade | city   |
+--------+--------+-------+-------+--------+
|    103 | chetan |    85 | B     | Mumbai |
+--------+--------+-------+-------+--------+
1 row in set (0.00 sec)


AND operator make sure that all the conditions must be true

OR will work if any of the condition is True

BETWEEN is used to get the values in the range 
BETWEEN 100 AND 200
Both inclusive

IN is used to get the results from the list provided
IN (e1, e2, e3, e4, .... en)
it will give if there is anyting from in
If we have something in IN then it will check for the rest of elements in IN

NOT is used to negate whole condition
NOT IN (e1, e2, e3, e4, .... en)
NOT BETWEEN 100 AND 200


LIMIT: 
	LIMIT is used to take only limited number of records back as a result from the SELECT section;
	If we specify LIMIT 5 then only 5 records will be returned if they are more than that otherwise actual number of records will be returned

mysql> SELECT * FROM student LIMIT 3;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
+--------+---------+-------+-------+--------+
3 rows in set (0.00 sec)


mysql> SELECT * FROM student WHERE marks < 75 LIMIT 5;
+--------+---------+-------+-------+-------+
| rollno | name    | marks | grade | city  |
+--------+---------+-------+-------+-------+
|    105 | emanuel |    12 | F     | Delhi |
+--------+---------+-------+-------+-------+
1 row in set (0.00 sec)


ORDER BY:
	Whenever we want data in the form of increasing and decreasing order then that can be obtained by using the ORDER BY clause 
	If we specify ASC then data will be in ascending order otherwise the data will be in descending order 

mysql> SELECT * FROM student ORDER BY marks ASC;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    105 | emanuel |    12 | F     | Delhi  |
|    101 | anil    |    78 | C     | Pune   |
|    106 | farah   |    82 | B     | Delhi  |
|    103 | chetan  |    85 | B     | Mumbai |
|    102 | bhumika |    93 | A     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)
Here we have got the data in the ascending order 
From low to high

mysql> SELECT * FROM student WHERE marks > 80 ORDER BY marks DESC;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    104 | dhruv   |    96 | A     | Delhi  |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
4 rows in set (0.01 sec)
Here data is in the form of descending order of all the students who have more than 80 marks 

Lets get the data of top 3 students
mysql> SELECT * FROM student ORDER BY marks DESC LIMIT 3;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    104 | dhruv   |    96 | A     | Delhi  |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
+--------+---------+-------+-------+--------+
3 rows in set (0.00 sec)

ORDER BY can be applied to string data as well where the strings will be sorted based on the Alphabetical Order

mysql> SELECT * FROM student ORDER BY city ASC;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    104 | dhruv   |    96 | A     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    101 | anil    |    78 | C     | Pune   |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)

Aggregate Functions:
	They are used to get the input and then output is given from those function
	There are different types of aggregate functions
	1. COUNT() :- Count is a function which will give us the conunt of all the entities that were given as input to that function

	2. MAX() :- Max will give the maximum result out of all the data that has been given as input to the data

	3. MIN() :- Min will give us the minimum result out of all the data that has been given as output to the data

	4. SUM() :- Sum gives us sum of all the input given to the data

	5. AVG() :- avg is used to get the average of all the data

mysql> SELECT COUNT(*) FROM student;
+----------+
| COUNT(*) |
+----------+
|        6 |
+----------+
1 row in set (0.07 sec)
Getting count of all the students in the dataset


mysql> SELECT COUNT(*) as count FROM student WHERE marks > 80;
+-------+
| count |
+-------+
|     4 |
+-------+
1 row in set (0.01 sec)
Number of all the students who has marks greater than 80

mysql> SELECT SUM(marks) as addition FROM student;
+----------+
| addition |
+----------+
|      446 |
+----------+
1 row in set (0.01 sec)
Sum of marks of all the students

mysql> SELECT MIN(marks) FROM student;
+------------+
| MIN(marks) |
+------------+
|         12 |
+------------+
1 row in set (0.01 sec)
Minimum marks of student

mysql> SELECT name FROM student WHERE marks = (SELECT MIN(marks) FROM student);
+---------+
| name    |
+---------+
| emanuel |
+---------+
1 row in set (0.01 sec)
Name of the student who has lowest marks

mysql> SELECT AVG(marks) FROM student;
+------------+
| AVG(marks) |
+------------+
|    74.3333 |
+------------+
1 row in set (0.00 sec)
Average of all the marks that every student has got
	

GROUP BY:
	This is the clause that is helpful for grouping the rows based on the certain conditions 
	We can get count or avg or min max of any particular group in the table

Get the minimum marks scored in city Pune
mysql> SELECT min(marks) FROM student GROUP BY city HAVING CITY = "Pune";
+------------+
| min(marks) |
+------------+
|         78 |
+------------+
1 row in set (0.00 sec)

count the number of students in each city

mysql> SELECT city as CITY, COUNT(*) as Count FROM student GROUP BY city;
+--------+-------+
| CITY   | Count |
+--------+-------+
| Pune   |     1 |
| Mumbai |     2 |
| Delhi  |     3 |
+--------+-------+
3 rows in set (0.00 sec)

If we have made the group by name of any column in the table then in SELECT statement we can specify only that column without aggregate function
If we want to use name of other column in the select statement then we have to make sure that column should be given to make a group by that column name also

SELECT name, city FROM student GROUP BY city;
This will give error as GROUP BY city has been done and then in SELECT statement name is mentioned 
name column can only be used here if it is used by the Aggregate function

Find average marks in each of the city
mysql> SELECT city as City, AVG(marks) as Average FROM student GROUP BY city;
+--------+---------+
| City   | Average |
+--------+---------+
| Pune   | 78.0000 |
| Mumbai | 89.0000 |
| Delhi  | 63.3333 |
+--------+---------+
3 rows in set (0.01 sec)

Write a query to find the average marks in each city in ascending order

mysql> SELECT city as City, AVG(marks) as Average FROM student GROUP BY city ORDER BY Average;
+--------+---------+
| City   | Average |
+--------+---------+
| Delhi  | 63.3333 |
| Pune   | 78.0000 |
| Mumbai | 89.0000 |
+--------+---------+
3 rows in set (0.01 sec)

For descending

mysql> SELECT city as City, AVG(marks) as Average FROM student GROUP BY city ORDER BY Average DESC;
+--------+---------+
| City   | Average |
+--------+---------+
| Mumbai | 89.0000 |
| Pune   | 78.0000 |
| Delhi  | 63.3333 |
+--------+---------+
3 rows in set (0.00 sec)


Problem:
	
mysql> CREATE TABLE payment (customer_id INT PRIMARY KEY, customer VARCHAR(50), mode VARCHAR(50), city VARCHAR(50));
Query OK, 0 rows affected (0.34 sec)

mysql> INSERT INTO payment (customer_id, customer, mode, city) VALUES (101, "Olivia Barrett", "Netbanking", "Portland");
Query OK, 1 row affected (0.05 sec)

mysql> SELECT * FROM payment;
+-------------+----------------+------------+----------+
| customer_id | customer       | mode       | city     |
+-------------+----------------+------------+----------+
|         101 | Olivia Barrett | Netbanking | Portland |
+-------------+----------------+------------+----------+
1 row in set (0.00 sec)

mysql> INSERT INTO payment (customer_id, customer, mode, city) VALUES
    -> (102, "Ethan Sinclair", "Credit Card", "Miami"),
    -> (103, "Maya Harnandez", "Credit Card", "Seattle"),
    -> (104, "Liam Donovan", "Netbanking", "Denver"),
    -> (105, "Sophia Nguyen", "Credit Card", "New Orleans"),
    -> (106, "Celeb Foster", "Debit Card", "Minneapolis"),
    -> (107, "Ava Patel", "Debit Card", "Phoenix"),
    -> (108, "Lucas Carter", "Netbanking", "Boston"),
    -> (109, "Isabella Martinez", "Netbanking", "Nashville"),
    -> (110, "Jackson Brooks", "Credit Card", "Boston");
Query OK, 9 rows affected (0.02 sec)
Records: 9  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM payment;
+-------------+-------------------+-------------+-------------+
| customer_id | customer          | mode        | city        |
+-------------+-------------------+-------------+-------------+
|         101 | Olivia Barrett    | Netbanking  | Portland    |
|         102 | Ethan Sinclair    | Credit Card | Miami       |
|         103 | Maya Harnandez    | Credit Card | Seattle     |
|         104 | Liam Donovan      | Netbanking  | Denver      |
|         105 | Sophia Nguyen     | Credit Card | New Orleans |
|         106 | Celeb Foster      | Debit Card  | Minneapolis |
|         107 | Ava Patel         | Debit Card  | Phoenix     |
|         108 | Lucas Carter      | Netbanking  | Boston      |
|         109 | Isabella Martinez | Netbanking  | Nashville   |
|         110 | Jackson Brooks    | Credit Card | Boston      |
+-------------+-------------------+-------------+-------------+
10 rows in set (0.01 sec)

for the given table, find the total payment according to each of the payment method

mysql> SELECT mode as Mode, COUNT(mode) FROM payment GROUP BY mode;
+-------------+-------------+
| Mode        | COUNT(mode) |
+-------------+-------------+
| Netbanking  |           4 |
| Credit Card |           4 |
| Debit Card  |           2 |
+-------------+-------------+
3 rows in set (0.01 sec)

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | A     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | A     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)

Find count of each grade in the class

mysql> SELECT grade as Grade, COUNT(name) FROM student GROUP BY grade ORDER BY grade;
+-------+-------------+
| Grade | COUNT(name) |
+-------+-------------+
| A     |           2 |
| B     |           2 |
| C     |           1 |
| F     |           1 |
+-------+-------------+
4 rows in set (0.00 sec)


HAVING clause:
	This is same as WHERE clause 
	As the WHERE clause is used to apply the condition on normal call HAVING is used to have the condition on the GROUP BY clause

find the number of students in the city where maximum marks in the city are larger than 90

mysql> SELECT city as City, COUNT(name) FROM student GROUP BY city HAVING MAX(marks) > 90;
+--------+-------------+
| City   | COUNT(name) |
+--------+-------------+
| Mumbai |           2 |
| Delhi  |           3 |
+--------+-------------+
2 rows in set (0.01 sec)
Here Pune has max marks of 78 which is less than that of 90 hence Pune is not included in here.

GENERAL ORDER OF Writing the columns

SELECT column(s)
FROM table_name
WHERE condition
GROUP BY column(s)
HAVING condition
ORDER BY column(s);

UPDATE operations:
	Existing data in the row can be updated using this clause

Syntax: 	
	UPDATE table_name SET col1 = val1, col2 = val2 WHERE condition

mysql> UPDATE student SET grade = "O" WHERE grade = "A";
Query OK, 2 rows affected (0.11 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | O     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | O     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)

Here we have updated the table using the update command where we have made the grade of student as 'O' who had got the grade as 'A'
UPDATE table_name SET c1 = v1, c2 = v2 WHERE condition;

Sometimes the mysql server can be in the safe mode
Whenever the safe mode is ON we will not be able to Modify any update in the documentation
Syntax to enable or disable the safe mode is
SET SQL_SAFE_UPDATES = 0;  //Disable
SET SQL_SAFE_UPDATES = 1;  //Enable

updates the marks of student who has marks of 12 to 72
mysql> UPDATE student SET marks = 72 WHERE rollno = 105;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    78 | C     | Pune   |
|    102 | bhumika |    93 | O     | Mumbai |
|    103 | chetan  |    85 | B     | Mumbai |
|    104 | dhruv   |    96 | O     | Delhi  |
|    105 | emanuel |    72 | F     | Delhi  |
|    106 | farah   |    82 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)

Now suppose we want to increament the marks of each of the student by 1
At that time we have to make sure that the student's marks must be updated in every row

mysql> UPDATE student SET marks = marks + 1;
Query OK, 6 rows affected (0.02 sec)
Rows matched: 6  Changed: 6  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    105 | emanuel |    83 | B     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.01 sec)


DELETE clause:
	Delete is used to delete the rows or records from the database
	If we dont specify any condition then delete operation will delete the whole set of rows
	So we have to make sure that we use correct condition to delete the row

Syntax:
	DELETE FROM table_name WHERER condition;

Lets delete the records of student who has scored marks less than 33;
mysql> DELETE FROM student WHERE marks < 33;
Query OK, 0 rows affected (0.01 sec)


Now lets update the marks of 105 with 12 again and then delete the record from the table

mysql> UPDATE student SET marks = 12 WHERE rollno = 105;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE student SET grade = "F" WHERE marks < 33;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    105 | emanuel |    12 | F     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
6 rows in set (0.00 sec)

mysql> DELETE FROM student WHERE marks < 33;
Query OK, 1 row affected (0.02 sec)

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)


Revisiting foreign key

mysql> CREATE TABLE course(id INT PRIMARY KEY, name VARCHAR(50));
Query OK, 0 rows affected (0.47 sec)

mysql> CREATE TABLE teacher (id INT PRIMARY KEY, name VARCHAR(50), dept_id INT,
    -> FOREIGN KEY(dept_id) REFERENCES course(id));
Query OK, 0 rows affected (0.17 sec)

mysql> INSERT INTO course(id, name) VALUES
    -> (101, "Science").
    -> ;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '.' at line 2
mysql> INSERT INTO course(id, name) VALUES
    -> (101, "Science"),
    -> (102, "English"),
    -> (103, "Hindi");
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO teacher(id, name, dept_id) VALUES
    -> (101, "Adam", 101),
    -> (102, "Bob", 103),
    -> (103, "Casey", 102),
    -> (104, "Donald", 102);
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM course;
+-----+---------+
| id  | name    |
+-----+---------+
| 101 | Science |
| 102 | English |
| 103 | Hindi   |
+-----+---------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM teacher;
+-----+--------+---------+
| id  | name   | dept_id |
+-----+--------+---------+
| 101 | Adam   |     101 |
| 102 | Bob    |     103 |
| 103 | Casey  |     102 |
| 104 | Donald |     102 |
+-----+--------+---------+
4 rows in set (0.00 sec)

The table whose PRIMARY KEY is used in other table is called as parent table 
The table in which PRIMARY KEY of other table is used as FOREIGN KEY is called as child table


Now as we have seen that there is relationship between the parent and child table hence there has to be a mechanism if there is any change in the parent table or deletion in the child table then changes should be reflected back to the child table

This mechanism is called as CASCADING

If we specify the option of ON DELETE CASCADE and ON UPDATE CASCADE in the child table then all the changes in the parent table or updation in the parent table will also be reflected back to the child table as well

Lets apply this in code

mysql> DROP table teacher;
Query OK, 0 rows affected (0.15 sec)

mysql> DROP table course;
Query OK, 0 rows affected (0.06 sec)

mysql> show tables;
+-------------------+
| Tables_in_college |
+-------------------+
| payment           |
| student           |
+-------------------+
2 rows in set (0.01 sec)

mysql> CREATE TABLE department(id INT PRIMARY KEY, name VARCHAR(50));
Query OK, 0 rows affected (0.08 sec)

mysql> CREATE TABLE teacher(id INT PRIMARY KEY, name VARCHAR(50), dept_id INT,
    -> FOREIGN KEY (dept_id) REFERENCES department(id)
    -> ON DELETE CASCADE
    -> ON UPDATE CASCADE);
Query OK, 0 rows affected (0.13 sec)


mysql> INSERT INTO department(id, name) VALUES
    -> (101, "Science"),
    -> (102, "English"),
    -> (103, "Hindi");
Query OK, 3 rows affected (0.03 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO teacher (id, name, dept_id) VALUES
    -> (101, "Adam", 101),
    -> (102, "Bob", 103),
    -> (103, "Casey", 102),
    -> (104, "Donald", 102);
Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

mysql> SELECT * FROM department;
+-----+---------+
| id  | name    |
+-----+---------+
| 101 | Science |
| 102 | English |
| 103 | Hindi   |
+-----+---------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM teacher;
+-----+--------+---------+
| id  | name   | dept_id |
+-----+--------+---------+
| 101 | Adam   |     101 |
| 102 | Bob    |     103 |
| 103 | Casey  |     102 |
| 104 | Donald |     102 |
+-----+--------+---------+
4 rows in set (0.00 sec)

mysql> DELETE FROM department WHERE id = 103;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM department;
+-----+---------+
| id  | name    |
+-----+---------+
| 101 | Science |
| 102 | English |
+-----+---------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM teacher;
+-----+--------+---------+
| id  | name   | dept_id |
+-----+--------+---------+
| 101 | Adam   |     101 |
| 103 | Casey  |     102 |
| 104 | Donald |     102 |
+-----+--------+---------+
3 rows in set (0.00 sec)

Here after deleting the records in the parent table we have also seen the records are being deleted in the child table also


mysql> UPDATE department SET id = 104 WHERE name = "Science";
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM department;
+-----+---------+
| id  | name    |
+-----+---------+
| 102 | English |
| 104 | Science |
+-----+---------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM teacher;
+-----+--------+---------+
| id  | name   | dept_id |
+-----+--------+---------+
| 101 | Adam   |     104 |
| 103 | Casey  |     102 |
| 104 | Donald |     102 |
+-----+--------+---------+
3 rows in set (0.00 sec)

Here in the above code example we have updated the code such that id changes in the parent table are now visible in the child table as well

ALTER command

ALTER is used to make changes in the table structure directly
Hence it can be included in the DDL list of commands

It can be used to add a column
It can be used to delete a column, rename the table and also to add a primary or a foreign key

//Add Column
ALTER TABLE table_name
ADD COLUMN column_name datatype Contsraints

mysql> ALTER TABLE student ADD COLUMN age INT NOT NULL;
Query OK, 0 rows affected (0.14 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+-----+
| rollno | name    | marks | grade | city   | age |
+--------+---------+-------+-------+--------+-----+
|    101 | anil    |    79 | C     | Pune   |   0 |
|    102 | bhumika |    94 | O     | Mumbai |   0 |
|    103 | chetan  |    86 | B     | Mumbai |   0 |
|    104 | dhruv   |    97 | O     | Delhi  |   0 |
|    106 | farah   |    83 | B     | Delhi  |   0 |
+--------+---------+-------+-------+--------+-----+
5 rows in set (0.00 sec)

mysql> UPDATE student SET AGE = 22;
Query OK, 5 rows affected (0.01 sec)
Rows matched: 5  Changed: 5  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+-----+
| rollno | name    | marks | grade | city   | age |
+--------+---------+-------+-------+--------+-----+
|    101 | anil    |    79 | C     | Pune   |  22 |
|    102 | bhumika |    94 | O     | Mumbai |  22 |
|    103 | chetan  |    86 | B     | Mumbai |  22 |
|    104 | dhruv   |    97 | O     | Delhi  |  22 |
|    106 | farah   |    83 | B     | Delhi  |  22 |
+--------+---------+-------+-------+--------+-----+
5 rows in set (0.00 sec)


DROPPING THE COLUMNS

mysql> ALTER TABLE student DROP COLUMN age;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)


RENAMING THE TABLE

mysql> ALTER TABLE student RENAME TO Vidyarthi;
Query OK, 0 rows affected (0.07 sec)

mysql> SELECT * FROM Vidyarhi;
ERROR 1146 (42S02): Table 'college.vidyarhi' doesn't exist
mysql> SELECT * FROM Vidyarthi;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | city   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.01 sec)

mysql> ALTER TABLE Vidyarthi RENAME TO student;
Query OK, 0 rows affected (0.05 sec)

We can even make changes in the name and datatype of the column too

ALTER TABLE table_name
CHANGE COLUMN old_name new_name new_datatype new_constraints
mysql> ALTER TABLE student CHANGE COLUMN city Shahar VARCHAR(50);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | Shahar |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)


// we can modify the columns too
ALTER TABLE table_name
MODIFY col_name new_datatype new_constraint

mysql> ALTER TABLE student MODIFY Shahar VARCHAR(50) NOT NULL;
Query OK, 0 rows affected (0.23 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | Shahar |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

Change the name of the column back to city
mysql> ALTER TABLE student CHANGE COLUMN Shahar City VARCHAR(50) NOT NULL;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | City   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

We can also see that name of the tables are not case sensitive 

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | City   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

mysql> SELECT * FROM Student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | City   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

mysql> SELECT * FROM STUDENT;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | City   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

mysql> ALTER TABLE student RENAME TO Student;
Query OK, 0 rows affected (0.01 sec)

mysql> show tables;
+-------------------+
| Tables_in_college |
+-------------------+
| department        |
| payment           |
| student           |
| teacher           |
+-------------------+
4 rows in set (0.00 sec)

ALTER changes schema hence it is called as DDL

TRUNCATE :
	It is used to delete all the data in the table
	DROP deletes the whole table
	TRUNCATE removes all the data in the table but table's schema will be as it is

Syntax :
	TRUNCATE TABLE table_name;

Here data from the teacher table can be seen and after truncating the table whole data will go empty
But the table will be there and its schema will also be there

mysql> SELECT * FROM teacher;
+-----+--------+---------+
| id  | name   | dept_id |
+-----+--------+---------+
| 101 | Adam   |     104 |
| 103 | Casey  |     102 |
| 104 | Donald |     102 |
+-----+--------+---------+
3 rows in set (0.00 sec)

mysql> TRUNCATE TABLE teacher;
Query OK, 0 rows affected (0.11 sec)

mysql> SELECT * FROM teacher;
Empty set (0.00 sec)

Practice Question:
1. Change the name of the column from name to full_name in student table
2. Delete all the students who scored marks less than 80
3. Delete the column grades

mysql> SELECT * FROM student;
+--------+---------+-------+-------+--------+
| rollno | name    | marks | grade | City   |
+--------+---------+-------+-------+--------+
|    101 | anil    |    79 | C     | Pune   |
|    102 | bhumika |    94 | O     | Mumbai |
|    103 | chetan  |    86 | B     | Mumbai |
|    104 | dhruv   |    97 | O     | Delhi  |
|    106 | farah   |    83 | B     | Delhi  |
+--------+---------+-------+-------+--------+
5 rows in set (0.00 sec)

mysql> ALTER TABLE Student CHANGE name full_name VARCHAR(50);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+-----------+-------+-------+--------+
| rollno | full_name | marks | grade | City   |
+--------+-----------+-------+-------+--------+
|    101 | anil      |    79 | C     | Pune   |
|    102 | bhumika   |    94 | O     | Mumbai |
|    103 | chetan    |    86 | B     | Mumbai |
|    104 | dhruv     |    97 | O     | Delhi  |
|    106 | farah     |    83 | B     | Delhi  |
+--------+-----------+-------+-------+--------+
5 rows in set (0.00 sec)


mysql> DELETE FROM student WHERE marks < 80;
Query OK, 1 row affected (0.01 sec)

mysql> ALTER TABLE student DROP COLUMN grade;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+--------+-----------+-------+--------+
| rollno | full_name | marks | City   |
+--------+-----------+-------+--------+
|    102 | bhumika   |    94 | Mumbai |
|    103 | chetan    |    86 | Mumbai |
|    104 | dhruv     |    97 | Delhi  |
|    106 | farah     |    83 | Delhi  |
+--------+-----------+-------+--------+
4 rows in set (0.00 sec)

JOINS IN SQL
Joins are used to combine the result in the two table based on the common columns in the two tables
Joins can also be prepared by using Foreign key but it is not neccessary to have it 
Only thing that is needed is that both of those tables must contain the common column in the table

INNER JOIN:
	This will return the common data in both the tables
	Interchange in the names of the table is possible and it will give us the same result no matter what in the database
	But it can't be possible to interchange the names of tables in left or right join
	
Syntax:
SELECT column(s)
FROM tableA
INNER JOIN tableB
ON tableA.col_name = tableB.col_name;

mysql> ALTER TABLE student RENAME TO stud;
Query OK, 0 rows affected (0.09 sec)

mysql> CREATE TABLE student (student_id INT PRIMARY KEY, name VARCHAR(50));
Query OK, 0 rows affected (0.08 sec)

mysql> INSERT INTO student(student_id, name) VALUES
    -> (101, "adam"),
    -> (102, "bob"),
    -> (103, "casey");
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> CREATE TABLE course(student_id INT PRIMARY KEY, course VARCHAR(50));
Query OK, 0 rows affected (0.16 sec)

mysql> INSERT INTO course(student_id, course) VALUES
    -> (102, "english"),
    -> (105, "math"),
    -> (103, "science"),
    -> (107, "computer science");
Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> CREATE TABLE result (student_id INT PRIMARY KEY, name VARCHAR(50), course VARCHAR(50));
Query OK, 0 rows affected (0.07 sec)

mysql> INSERT INTO result(student_id, name, course) VALUES
    -> (102, "bob", "english"),
    -> (103, "casey", "science");
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM student;
+------------+-------+
| student_id | name  |
+------------+-------+
|        101 | adam  |
|        102 | bob   |
|        103 | casey |
+------------+-------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM course;
+------------+------------------+
| student_id | course           |
+------------+------------------+
|        102 | english          |
|        103 | science          |
|        105 | math             |
|        107 | computer science |
+------------+------------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM result;
+------------+-------+---------+
| student_id | name  | course  |
+------------+-------+---------+
|        102 | bob   | english |
|        103 | casey | science |
+------------+-------+---------+
2 rows in set (0.00 sec)


Left Join:
	It will return all the data from the left table and matching data from the right table
	Data from either left or common of left and right

Right Join:
	This will return matching data from the left table and all the data from the rigt table
	Data from the right or common data from right and left

Full Join:
	This will return all the records from both of the tables 
